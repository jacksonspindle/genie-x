/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 phone.glb 
*/
import React, { useRef, useState } from "react";
import { useGLTF, useScroll, useTexture } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { a, useSpring } from "@react-spring/three";
import iphoneScreen from "../assets/iphoneScreen.png";
import * as THREE from "three";

export function Phone({ setHasRotated, setScrollAfterRotation, props }) {
  const { nodes, materials } = useGLTF("/phone.glb");
  const phoneRef = useRef();
  const scroll = useScroll();

  // Load the screen texture
  const screenTexture = useTexture(iphoneScreen); // Update with your image path
  const screenMaterial = new THREE.MeshBasicMaterial({ map: screenTexture });

  // Prevent tiling
  screenTexture.wrapS = THREE.ClampToEdgeWrapping;
  screenTexture.wrapT = THREE.ClampToEdgeWrapping;

  // Adjust the size and position of the image (making it smaller)
  const repeatX = 3.5; // Smaller size for width
  const repeatY = 3.5; // Smaller size for height
  screenTexture.repeat.set(repeatX, repeatY);

  // Center the image
  screenTexture.offset.set((-0.78 - repeatX) / 2, (1.85 - repeatY) / 2);

  // Use useSpring to create animated values
  // UseSpring for smooth rotation animation
  const [springs, api] = useSpring(() => ({
    rotation: [0, Math.PI, Math.PI], // Initial rotation of the phone
    config: { mass: 1, tension: 170, friction: 26 },
  }));

  useFrame(() => {
    const maxRotation = 2 * Math.PI; // 360 degrees for full rotation
    const targetRotationY = Math.min(
      Math.PI + scroll.offset * Math.PI * 2,
      maxRotation
    );

    // Track if rotation has completed
    if (targetRotationY >= maxRotation) {
      setHasRotated(true);

      // Calculate additional scroll after full rotation
      const extraScroll = scroll.offset * 2 - 1; // subtract the initial full rotation
      const percentScrolledAfterRotation = Math.max(0, extraScroll); // scroll only after full rotation
      setScrollAfterRotation(percentScrolledAfterRotation);
    }

    // Animate rotation
    api.start({
      rotation: [0, targetRotationY, Math.PI],
    });
  });

  return (
    <>
      <group {...props} dispose={null}>
        <a.group
          ref={phoneRef}
          position={[0, 0, 0]} // Updated position with scroll
          rotation={springs.rotation}
          scale={[0.6, 0.6, 0.7]}
        >
          <mesh
            geometry={nodes.Cube009_1.geometry}
            material={materials["Material.006"]}
          />
          <mesh
            geometry={nodes.Cube009_2.geometry}
            material={materials["Material.025"]}
          />
          <mesh
            geometry={nodes.Cube009_3.geometry}
            material={materials["Material.037"]}
          />
          <mesh geometry={nodes.Cube009_4.geometry}>
            <meshBasicMaterial map={screenTexture} />
          </mesh>
          <mesh
            geometry={nodes.Cube009_5.geometry}
            material={materials["Material.036"]}
          />
          <mesh
            geometry={nodes.Cube009_6.geometry}
            material={materials["Material.001"]}
          />
          <mesh
            geometry={nodes.Cube009_7.geometry}
            material={materials["Material.005"]}
          />
          <mesh
            geometry={nodes.Cube009_8.geometry}
            material={materials["Material.029"]}
          />
          <mesh
            geometry={nodes.Cube009_9.geometry}
            material={materials["Material.045"]}
          />
          <mesh
            geometry={nodes.Cube009_10.geometry}
            material={materials["Material.046"]}
          />
          <mesh
            geometry={nodes.Cube009_11.geometry}
            material={materials.Material}
          />
          <mesh
            geometry={nodes.Cube009_12.geometry}
            material={materials["Material.021"]}
          />
          <mesh
            geometry={nodes.Cube009_13.geometry}
            material={materials["Material.019"]}
          />
          <mesh
            geometry={nodes.Cube009_14.geometry}
            material={materials["Material.042"]}
          />
          <mesh
            geometry={nodes.Cube009_15.geometry}
            material={materials["Material.047"]}
          />
          <mesh
            geometry={nodes.Cube009_16.geometry}
            material={materials["Material.003"]}
          />
          <mesh
            geometry={nodes.Cube009_17.geometry}
            material={materials["Material.004"]}
          />
        </a.group>
      </group>
    </>
  );
}

useGLTF.preload("/phone.glb");
